from scipy.linalg import sqrtm
import numpy as np
import os
from scipy.linalg import sqrtm
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt


def read_bv_force_results(directory: str):
    """
    Reads all .npz result files generated by compute_forces_bv_to_files
    from the specified directory and returns a structured NumPy array.

    Parameters
    ----------
    directory : str
        Path to the folder containing result .npz files.

    Returns
    -------
    np.ndarray
        Structured NumPy array with fields:
        'b', 'v', 'mean_force', 'err', 'forces', 'phases'
    """
    records = []

    for fname in sorted(os.listdir(directory)):
        if fname.endswith('.npz'):
            filepath = os.path.join(directory, fname)
            npz = np.load(filepath)

            records.append((
                npz['b'].item(),
                npz['v'].item(),
                npz['mean_force'].item(),
                npz['err'].item(),
                npz['forces'],
                npz['phases']
            ))

    dtype = np.dtype([
        ('b', 'f8'),
        ('v', 'f8'),
        ('mean_force', 'f8'),
        ('err', 'f8'),
        ('forces', 'O'),  # Object for variable-length array
        ('phases', 'O')   # Object for variable-length 2D array
    ])

    return np.array(records, dtype=dtype)


def fidelity(rho1, rho2):
    """
    Compute the quantum fidelity between two density matrices.

    Parameters
    ----------
    rho1, rho2 : np.ndarray
        2D complex density matrices of the same shape.

    Returns
    -------
    float
        Fidelity value between 0 and 1.
    """
    sqrt_rho1 = sqrtm(rho1)
    inner_term = sqrtm(sqrt_rho1 @ rho2 @ sqrt_rho1)
    return np.real(np.trace(inner_term)) ** 2

def plot_density_matrix_fidelity(res, res_2):
    """
    Given two result objects with .t and .rho (6x6xT), compute and plot fidelity over time.

    Parameters
    ----------
    res : object
        Object with attributes `.t` (array of times) and `.rho` (6x6xT density matrix).
    res_2 : object
        Second result object to compare against (possibly different time sampling).

    Returns
    -------
    list of float
        Fidelity values at each time point in res.t.
    """
    # Reshape rho to shape (T, 6, 6)
    rho1_list = np.transpose(res.rho, (2, 0, 1))     # (N, 6, 6)
    rho2_list = np.transpose(res_2.rho, (2, 0, 1))   # (M, 6, 6)

    # Flatten rho2 for interpolation
    rho2_flat = rho2_list.reshape((len(res_2.t), -1))  # (M, 36)

    # Interpolate each element over res.t
    interp_func = interp1d(res_2.t, rho2_flat.T, kind='linear', fill_value="extrapolate")
    rho2_interp_flat = interp_func(res.t).T            # (N, 36)
    rho2_interp = rho2_interp_flat.reshape((-1, 6, 6))  # (N, 6, 6)

    # Compute fidelity at each time point
    fidelities = [fidelity(r1, r2) for r1, r2 in zip(rho1_list, rho2_interp)]

    # Plot
    plt.figure(figsize=(8, 5))
    plt.plot(res.t, fidelities, label='Fidelity')
    plt.xlabel("Time")
    plt.ylabel("Fidelity")
    plt.ylim(0, 1.05)
    plt.grid(True)
    plt.title("Fidelity between Density Matrices Over Time")
    plt.legend()
    plt.tight_layout()
    plt.show()

    return fidelities